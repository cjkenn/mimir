#pragma once

#include <memory>
#include "token.h"
#include "lexer.h"
#include "ast.h"
#include "symbol_table.h"
#include "error.h"
#include "parser_result.h"

namespace mimir {
class Parser {
 public:
  Parser(std::shared_ptr<Lexer> lexer,
	 std::shared_ptr<SymbolTable> sym_tab);

  ~Parser() {};

  // Parses an entire file and attempts to build an ast. A ParserResult class is returned,
  // which should contain a list of any parsing errors encountered, as well as the ast that
  // was generated by the parser.
  // The ParserResult should be checked for any errors before continuing with compilation,
  // as the ast could be incorrect if there are parsing errors that go unnoticed.
  ParserResult Parse();

 private:
  AstNodePtr Program();
  AstNodePtr Statement();
  AstNodePtr ParenExpr();
  AstNodePtr Expr();
  AstNodePtr Test();
  AstNodePtr BinOp();
  AstNodePtr Term();
  AstNodePtr Params();

  // Checks the current token type and if it is equal to expected_type, advances
  // the token and returns. If the current token is not what we expect, we create
  // a new error and add it to the parser result.
  void Expect(const TokenType expected_type);

  // Calls the Lex() method and sets curr_tkn_ as the result.
  void GetNextTkn();

  // True if curr_tkn_ is a binary operator.
  bool CurrTknIsBinOpTkn();

  // Maps a token type to an ast type for binary operator tokens.
  AstType GetBinOpAstFromTkn();

  // True if curr_tkn_ is an equality operator.
  bool CurrTknIsTestTkn();

  // Maps a token type to an ast type for equality test tokens.
  AstType GetTestAstFromTkn();

  std::shared_ptr<Lexer> lexer_;
  std::shared_ptr<SymbolTable> sym_tab_;
  Token curr_tkn_;
  ParserResult result_;
};
}
